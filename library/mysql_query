#!/usr/bin/env python
# -*- coding: utf-8 -*-

DOCUMENTATION = """
    ---
module: mysql_query
author:
    - 'Elmar Athmer'
short_description: Insert/update/remove rows in a mysql table.
description:
  - 'This module set values in a mysql table, or insert records. Useful for webapplications that store configurations
     in database. E.g. icingaweb2 requires the initial user to be inserted into the database.'
options:
  identifiers:
    required: true
    description:
      - dictionary of values to identifier a row, i.e. determine if the row exists, needs to be updated etc.
  values:
    required: false
    description:
        - dictionary of values that should be 'enforced', i.e. either updated (if the row has been found by it's
          identifiers) or used during insert
  defaults:
    required: false
    description:
        - dictionary of additional values that will be used iff an insert is required.
"""

EXAMPLES = """

"""

try:
    import MySQLdb
except ImportError:
    mysqldb_found = False
else:
    mysqldb_found = True

INSERT_REQUIRED = 1
UPDATE_REQUIRED = 2
NO_ACTION_REQUIRED = 3
ERR_NO_SUCH_TABLE = 4


def change_required(cursor, table, identifiers, desired_values):
    """
    check if a change is required
    :param cursor: cursor object able to execute queries
    :param table: name of the table to look into
    :type table: str
    :param identifiers: a list of tuples (column name, value) to use in where clause
    :type identifiers: list
    :param desired_values: a list of tuples (column name, values) that the record should match
    :type desired_values: list
    :return: one of INSERT_REQUIRED, UPDATE_REQUIRED or NO_ACTION_REQUIRED
    :rtype: int
    """
    query = "select %(columns)s from %(table)s where %(values)s" % dict(
        table=table,
        columns=", ".join([c for c, v in desired_values]),
        values=" AND ".join(map(lambda x: "%s='%s'" % x, identifiers)),
    )

    try:
        res = cursor.execute(query)
    except MySQLdb.ProgrammingError, e:
        (errcode, message) = e.args
        if errcode == 1146:
            return ERR_NO_SUCH_TABLE
        else:
            raise e

    if res == 0:
        return INSERT_REQUIRED

    # bring the values argument into shape to compare directly to fetchone() result
    expected_query_result = tuple([val for k, val in desired_values])
    actual_result = cursor.fetchone()
    if expected_query_result == actual_result:
        return NO_ACTION_REQUIRED

    # a record has been found but does not match the desired values
    return UPDATE_REQUIRED

def execute_action(cursor, action, table, identifier, values, defaults):
    """
    when not running in check mode, this function carries out the required changes
    :rtype: dict
    :param cursor:
    :param table:
    :param identifier:
    :param values:
    :param defaults:
    :return: a summary of the action done usable as kwargs for ansible
    """
    try:
        if action == INSERT_REQUIRED:
            return {'failed': True, 'msg': 'not yet implemented'}
        elif action == UPDATE_REQUIRED:
            return {'failed': True, 'msg': 'not yet implemented'}
        else:
            return {'failed': True, 'msg': 'Internal Error: unknown action required'}
    except Exception, e:
        return {'failed': True, 'msg': 'updating/inserting the record failed due to "%s".' % str(e)}

def update_record(cursor, table, identifier_column, identifier, value_column, value):
    query = """UPDATE {0} SET {1} = %s WHERE {2} = %s""".format(table, value_column, identifier_column)

    cursor.execute(query, (value, identifier))

def insert_record(param, table, identifiers, values, defaults):
    pass


def build_connection_parameter(params):
    """
    fetch mysql connection parameters consumable by mysqldb.connect from module args or ~/.my.cnf if necessary
    :param params:
    :return:
    :rtype: dict
    """
    # TODO: read ~/.my.cnf, set sane defaults etc.

    # map: (ansible_param_name, mysql.connect's name)
    param_name_map = [
            ('login_user', 'user'),
            ('login_password', 'passwd'),
            ('name', 'db'),
            ('login_host', 'host'),
            ('login_port', 'port'),
            ('login_unix_socket', 'unix_socket')
            ]

    t = [(mysql_name, params[ansible_name]) 
            for (ansible_name, mysql_name) in param_name_map
            if ansible_name in params and params[ansible_name]
        ]

    return dict(t)

def connect(connection, module):
    # TODO: make this wrappable in a with: statements, looks cleaner in the main-function
    try:
        db_connection = MySQLdb.connect(**connection)
        return db_connection
    except Exception, e:
        module.fail_json(msg="Error connecting to mysql database: %s" % str(e))

def extract_column_value_maps(parameter):
    """
    extract mysql-quoted tuple-lists for parameters given as ansible params
    :param parameter:
    :return:
    """
    if parameter:
        for column, value in parameter.items():
            yield (mysql_quote_identifier(column, 'column'), long(value) if value.isdigit() else value)
def failed(action):
    return action == ERR_NO_SUCH_TABLE


def main():
    module = AnsibleModule(
        argument_spec = dict(
            login_user=dict(default=None),
            login_password=dict(default=None),
            login_host=dict(default="localhost"),
            login_port=dict(default=3306, type='int'),
            login_unix_socket=dict(default=None),
            name=dict(required=True, aliases=['db']),
            state=dict(default="present", choices=['absent', 'present']),

            table=dict(required=True),

            identifiers=dict(required=True, type='dict'),
            values=dict(default=None, type='dict'),
            defaults=dict(default=None, type='dict'),

            allow_insert=dict(default=False, type='bool'),
            limit=dict(default=1, type='int'),
        ),
        supports_check_mode=True
    )

    if not mysqldb_found:
        module.fail_json(msg="the python mysqldb module is required")

    if module.params["state"] == "absent":
        module.fail_json(msg="state=absent is not yet implemented")

    # mysql_quote all identifiers and get the parameters into shape
    table = mysql_quote_identifier(module.params['table'], 'table')
    identifiers = list(extract_column_value_maps(module.params['identifiers']))
    values = list(extract_column_value_maps(module.params['values']))
    defaults = list(extract_column_value_maps(module.params['defaults']))

    exit_messages = {
        INSERT_REQUIRED: dict(changed=True, msg='No such record, need to insert'),
        UPDATE_REQUIRED: dict(changed=True, msg='Records needs to be updated'),
        NO_ACTION_REQUIRED: dict(changed=False),
        ERR_NO_SUCH_TABLE: dict(failed=True, msg='No such table %s' % table)
    }

    db_connection = connect(build_connection_parameter(module.params), module)

    # find out what needs to be done (independently of check-mode)
    required_action = change_required(db_connection.cursor(), table, identifiers, values)

    if module.check_mode or failed(required_action):
        exit_message = exit_messages[required_action]
    else:
        exit_message = execute_action(db_connection.cursor(), required_action, table, identifiers, values, defaults)

    db_connection.close()

    if exit_message.has_key('failed') and exit_message['failed']:
        module.fail_json(**exit_message)
    else:
        module.exit_json(**exit_message)

# include magic from lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

from ansible.module_utils.database import *
if __name__ == '__main__':
    main()
