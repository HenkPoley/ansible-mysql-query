#!/usr/bin/env python
# -*- coding: utf-8 -*-

from ansible.module_utils.database import *
from contextlib import closing
from operator import itemgetter

DOCUMENTATION = """
---
module: mysql_query
author:
    - 'Elmar Athmer'
short_description: Insert/update/remove rows in a mysql table.
description:
  - This module sets values in a mysql table, or insert records. Useful for webapplications that store configurations
     in database.
options:
  table:
    required: true
    description:
      - table where to insert/update records
  identifiers:
    required: true
    description:
      - dictionary of values to identifier a row, i.e. determine if the row exists, needs to be updated etc.
  values:
    required: false
    description:
        - dictionary of values that should be 'enforced', i.e. either updated (if the row has been found by it's
          identifiers) or used during insert
  defaults:
    required: false
    description:
        - dictionary of additional values that will be used iff an insert is required.
"""

EXAMPLES = """
- name: update john@example.com's password and role
  mysql_query:
    name: ansible-playbook-example
    table: simple_table
    login_host: ::1
    login_user: root
    login_password: password
    identifiers:
      some_id: 23
      email: 'john@example.com'
    values:
      role: 'superadmin'
      password:
        function: PASSWORD(%s)
        value: 'very_secret'
    defaults:
      department_id: 23 # will not be changed since this is no insert
      last_login: 0

- name: insert a row
  mysql_query:
    name: ansible-playbook-example
    table: simple_table
    login_host: ::1
    login_user: root
    login_password: password
    identifiers:
      some_id: 23
      email: 'richard@example.com'
    values:
      role: 'ceo'
      password:
        function: PASSWORD(%s)
        value: 'initial_password'
    defaults:
      department_id: 23
      last_login: 100
"""

try:
    import MySQLdb
except ImportError:
    mysqldb_found = False
else:
    mysqldb_found = True

INSERT_REQUIRED = 1
UPDATE_REQUIRED = 2
NO_ACTION_REQUIRED = 3
ERR_NO_SUCH_TABLE = 4


def pluck(attr, lst):
    return map(itemgetter(attr), lst)


def change_required(cursor, table, identifiers, desired_values):
    """
    check if a change is required
    :param cursor: cursor object able to execute queries
    :param table: name of the table to look into
    :type table: str
    :param identifiers: a list of dicts (column, placeholder, value) to use in where clause
    :type identifiers: List[dict]
    :param desired_values: a list of dicts (column, placeholder, value) that the record should match
    :type desired_values: List[dict]
    :return: one of INSERT_REQUIRED, UPDATE_REQUIRED or NO_ACTION_REQUIRED
    :rtype: int
    """

    # build the select-expression for each column that compares the actual value to the desired value
    # (e.g. "column != %s" or "column != FUNCTION(%s)"),
    # so MySQL yields '1' for each field that has the desired value and '0' for fields that require a change.
    # We will join these per-column-expressions with OR so the query simply returns '1' if an update is required
    projections = ['{0} != {1}'.format(dv['column'], dv['placeholder']) for dv in desired_values]

    # build the filters (using the identifiers) for the where-statement
    filters = ['{0} = {1}'.format(i['column'], i['placeholder']) for i in identifiers]

    query = "select ({projections}) as is_update_required from {table} where {filters}".format(
        table=table,
        projections=" OR ".join(projections),
        filters=" AND ".join(filters),
    )

    try:
        res_count = cursor.execute(query, pluck('value', desired_values) + pluck('value', identifiers))
    except MySQLdb.ProgrammingError, e:
        (errcode, message) = e.args
        if errcode == 1146:
            return ERR_NO_SUCH_TABLE
        else:
            raise e

    # no record with such identifiers -> insert required
    if res_count == 0:
        return INSERT_REQUIRED

    # check if the (only) selection 'is_update_require' (the boolean expression we built into the query) is true
    if (1,) == cursor.fetchone():
        return UPDATE_REQUIRED

    # record found and all fields match the desired values
    return NO_ACTION_REQUIRED


def execute_action(cursor, action, table, identifier, values, defaults):
    """
    when not running in check mode, this function carries out the required changes
    :param action: action to execute as determined by 'change_required'/check mode,
                   must be one of INSERT_REQUIRED or UPDATE_REQUIRED
    :rtype: dict
    :param cursor:
    :param table:
    :param identifier:
    :param values:
    :param defaults:
    :return: a summary of the action done, usable as kwargs for ansible
    """
    try:
        if action == INSERT_REQUIRED:
            return insert_record(cursor, table, identifier, values, defaults)
        elif action == UPDATE_REQUIRED:
            return update_record(cursor, table, identifier, values)
        else:
            return {'failed': True, 'msg': 'Internal Error: unknown action "{0}" required'.format(action)}
    except Exception, e:
        return {'failed': True, 'msg': 'updating/inserting the record failed due to "{0}".'.format(str(e))}


def update_record(cursor, table, identifiers, desired_values):
    """
    update records
    """
    filters = ' AND '.join(['{column} = {placeholder}'.format(**i) for i in identifiers])
    updates = ', '.join(['{column} = {placeholder}'.format(**v) for v in desired_values])

    query = "UPDATE {0} set {1} where {2} limit 1".format(table, updates, filters)

    cursor.execute(query, pluck('value', desired_values) + pluck('value', identifiers))
    return dict(changed=True, msg='Successfully updated one row')


def insert_record(cursor, table, identifiers, values, defaults):
    columns = pluck('column', identifiers) + pluck('column', values) + pluck('column', defaults)
    placeholder = pluck('placeholder', identifiers) + pluck('placeholder', values) + pluck('placeholder', defaults)

    query = "insert into {0} ({1}) values ({2})".format(
        table,
        ", ".join(columns),
        ", ".join(placeholder),
    )

    cursor.execute(query, pluck('value', identifiers) + pluck('value', values) + pluck('value', defaults))
    return dict(changed=True, msg='Successfully inserted a new row')


def build_connection_parameter(params):
    """
    fetch mysql connection parameters consumable by mysqldb.connect from module args or ~/.my.cnf if necessary
    :param params:
    :return:
    :rtype: dict
    """
    # TODO: read ~/.my.cnf, set sane defaults etc.

    # map: (ansible_param_name, mysql.connect's name)
    param_name_map = [
        ('login_user', 'user'),
        ('login_password', 'passwd'),
        ('name', 'db'),
        ('login_host', 'host'),
        ('login_port', 'port'),
        ('login_unix_socket', 'unix_socket')
    ]

    t = [(mysql_name, params[ansible_name])
         for (ansible_name, mysql_name) in param_name_map
         if ansible_name in params and params[ansible_name]
         ]

    return dict(t)


def connect(connection, module):
    try:
        db_connection = MySQLdb.connect(**connection)
        return db_connection
    except Exception, e:
        module.fail_json(msg="Error connecting to mysql database: {0}".format(str(e)))


def normalize_parameters(parameters):
    """
    normalize values as passed from playbooks to a list of dicts,
    correctly typed and casted

    {'password': {'function': 'PASSWORD(%s)', 'value': 'very_secret'}, 'role': 'superadmin'}
        => [
             {'column': 'password', 'placeholder': 'PASSWORD(%s)', 'value': 'very_secret'},
             {'column': 'role', 'placeholder': '%s', 'value': 'superadmin'},
         ]
    :param parameters:
    :return:
    """
    def normalize_value(v):
        if isinstance(v, int):
            return '%s', long(v)
        if isinstance(v, str) and v.isdigit():
            return '%s', long(v)
        if isinstance(v, dict):
            # TODO: raise an error/call module.fail if (not v has 'value'):
            # if the user passes a dictionary, it should have an entry for key 'value'
            return v.get('function', '%s'), normalize_value(v['value'])[1]
        return '%s', v

    def normalize_item(column, value):
        (placeholder, v) = normalize_value(value)
        return dict(
            column=mysql_quote_identifier(column, 'column'),
            placeholder=placeholder,
            value=v,
        )

    return [normalize_item(*p) for p in parameters.items()]


def failed(action):
    return action == ERR_NO_SUCH_TABLE


def main():
    module = AnsibleModule(
        argument_spec=dict(
            login_user=dict(default=None),
            login_password=dict(default=None),
            login_host=dict(default="localhost"),
            login_port=dict(default=3306, type='int'),
            login_unix_socket=dict(default=None),
            name=dict(required=True, aliases=['db']),
            state=dict(default="present", choices=['absent', 'present']),

            table=dict(required=True),

            identifiers=dict(required=True, type='dict'),
            values=dict(default=None, type='dict'),
            defaults=dict(default=None, type='dict'),

            # allow_insert=dict(default=False, type='bool'),
            # limit=dict(default=1, type='int'),
        ),
        supports_check_mode=True
    )

    if not mysqldb_found:
        module.fail_json(msg="the python mysqldb module is required")

    if module.params["state"] == "absent":
        module.fail_json(msg="state=absent is not yet implemented")

    # mysql_quote all identifiers and get the parameters into shape
    table = mysql_quote_identifier(module.params['table'], 'table')
    identifiers = normalize_parameters(module.params['identifiers'])
    values = normalize_parameters(module.params['values'])
    defaults = normalize_parameters(module.params['defaults'])

    exit_messages = {
        INSERT_REQUIRED: dict(changed=True, msg='No such record, need to insert'),
        UPDATE_REQUIRED: dict(changed=True, msg='Records needs to be updated'),
        NO_ACTION_REQUIRED: dict(changed=False),
        ERR_NO_SUCH_TABLE: dict(failed=True, msg='No such table {0}'.format(table))
    }

    with closing(connect(build_connection_parameter(module.params), module)) as db_connection:
        # find out what needs to be done (independently of check-mode)
        required_action = change_required(db_connection.cursor(), table, identifiers, values)

        # if we're in check mode, there's no action required, or we already failed: directly set the exit_message
        if module.check_mode or required_action == NO_ACTION_REQUIRED or failed(required_action):
            exit_message = exit_messages[required_action]
        else:
            # otherwise, execute the required action to get the exit message
            exit_message = execute_action(db_connection.cursor(), required_action, table, identifiers, values, defaults)
            db_connection.commit()

    if 'failed' in exit_message and exit_message.get('failed'):
        module.fail_json(**exit_message)
    else:
        module.exit_json(**exit_message)


from ansible.module_utils.basic import *

if __name__ == '__main__':
    main()
